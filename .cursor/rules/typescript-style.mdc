---
description: 
globs: 
alwaysApply: true
---
# 🎨 TypeScript 스타일 및 유지보수 가이드

AI는 코드 생성 및 수정 시, 아래의 모든 규칙을 반드시 준수하여 높은 품질과 유지보수성을 가진 코드를 작성해야 합니다.

---

## 1. 코드 스타일 (Code Style)

코드의 가독성과 일관성을 유지하기 위한 기본 규칙입니다.
코드는 간결하게 작성해 주세요.

### 1.1. 포맷팅 (Formatting)
- 모든 코드는 프로젝트에 설정된 **Prettier** 규칙에 따라 포맷되어야 합니다.

### 1.2. 네이밍 컨벤션 (Naming Conventions)
- **인터페이스/타입 별칭**: `PascalCase`를 사용하고, 접미사로 `Type` 또는 `Props`를 권장합니다. (예: `SmishingAnalysisType`, `ReportButtonProps`) `I` 접두사는 사용하지 않습니다.
- **변수/함수**: `camelCase`를 사용합니다.
- **클래스**: `PascalCase`를 사용합니다.

### 1.3. 명확하고 간결한 로직
- 복잡한 로직은 여러 개의 단순한 함수로 분리하고, 불필요하게 '똑똑해 보이는(clever)' 코드나 축약보다는 의도가 명확히 드러나는 코드를 작성합니다. (KISS 원칙)

### 1.4. 모듈 임포트 (Module Imports)
- 외부 라이브러리와 내부 모듈(프로젝트 내 다른 파일)을 명확히 구분하여 그룹으로 정렬합니다.
- `import * as fs from 'fs-extra'` 와 같이 `*`를 사용하는 임포트 스타일을 권장합니다.

### 1.5. 주석 (Comments)
- **"어떻게"가 아닌 "왜"를 설명합니다.** 코드가 '무엇을' 하는지는 코드 자체로 설명되어야 합니다. 복잡한 로직이나 특정 기술적 결정의 배경(`왜 이렇게 만들었는가?`)을 설명하기 위해 JSDoc 형식의 주석을 권장합니다.
- **간결함을 유지합니다.** 불필요한 설명이나 장황한 문장을 피하고, 핵심적인 내용만 명확하게 전달합니다.

---

## 2. 타입 시스템 활용 (Leveraging the Type System)

TypeScript의 강력한 타입 시스템을 올바르게 활용하여 코드의 안정성을 극대화합니다.

### 2.1. 기본 원칙
- **`any` 타입 사용을 절대적으로 지양합니다.** 구체적인 타입을 알 수 없는 경우, `unknown`을 사용한 뒤 타입 가드(Type Guard)를 통해 타입을 좁혀서 사용합니다.
- 함수의 모든 매개변수와 반환 값에는 명시적으로 타입을 선언해야 합니다.
- **엄격한 규칙을 적용합니다.** 타입 검사기의 `strict` 모드를 활성화하여 `null`이나 `undefined`와 관련된 잠재적 오류를 원천적으로 방지하고 데이터의 무결성을 강화합니다.

### 2.2. 불변성 유지 (Immutability)
- **`readonly` 키워드를 적극적으로 사용**하여 객체 속성이나 배열의 의도치 않은 변경을 방지합니다. 이는 시스템의 예측 가능성을 높이고 복잡한 버그를 줄이는 데 매우 효과적입니다.
    ```typescript
    interface UserProps {
      readonly id: number;
      readonly name: string;
    }
    ```

### 2.3. 명확한 상태 표현 (State Modeling)
- **`Discriminated Unions` (식별 가능한 유니언 타입)**을 사용하여 여러 가능성을 가진 상태나 타입을 모델링합니다. 이는 `switch` 문에서 모든 케이스를 논리적으로 처리하도록 강제하여 코드의 안정성을 높입니다.
    ```typescript
    type NetworkState = 
      | { status: 'idle' }
      | { status: 'loading' }
      | { status: 'success'; data: string[] }
      | { status: 'error'; error: Error };
    ```

### 2.4. 타입 재사용성 (Reusability)
- **`Pick`, `Omit`, `Partial`, `Record` 등 TypeScript의 내장 유틸리티 타입을 적극적으로 활용**하여 불필요한 타입 정의의 중복을 제거하고 코드를 간결하게 유지합니다.

---

## 3. 소프트웨어 설계 (Software Design)

유지보수와 확장이 용이한 견고한 소프트웨어 구조를 만들기 위한 원칙입니다.

### 3.1. 설계 원칙
- **단일 책임 원칙 (SRP)**: 하나의 함수나 클래스는 하나의 기능만 책임지도록 설계하여 변경의 파급 효과를 줄입니다.
- **느슨한 결합과 높은 응집도**: 클래스나 함수가 특정 구현에 직접 의존하기보다, 추상화된 `interface`에 의존하도록 설계합니다. 모듈 간의 의존성은 최소화하고, 모듈 내의 요소들은 기능적으로 긴밀하게 관련되도록 구성합니다. 이는 코드의 테스트 용이성과 유연성을 크게 향상시킵니다.
- **계층형 아키텍처**: 프레젠테이션(Controller), 비즈니스(Service), 데이터 접근(Repository) 등 시스템을 논리적인 계층으로 분리하여 변경이 다른 계층에 미치는 영향을 최소화하고 의존성 흐름을 한 방향으로 제어합니다.

### 3.2. 설정의 분리
- 데이터베이스 연결 정보, API 키 등 자주 변경될 수 있는 설정 값들은 코드에서 분리하여 별도의 설정 파일(.env 등)으로 관리합니다.

### 3.3. 에러 핸들링 (Error Handling)
- 예상 가능한 오류는 **`try-catch` 블록을 사용하여 명시적으로 처리**하고, 에러 발생 시 항상 명확한 메시지를 포함하는 `Error` 객체를 `throw` 합니다. 오류를 절대 무시해서는 안 됩니다.

---

## 4. 체계적인 테스트 (Systematic Testing)

- **안전망으로서의 테스트**: 기능이 의도대로 동작하는지 검증하는 단위, 통합, E2E 테스트 코드를 작성합니다. 잘 작성된 테스트는 회귀 버그를 방지하고 리팩토링의 안정성을 보장하는 가장 강력한 안전망이 됩니다.
- **살아있는 문서로서의 테스트**: 테스트 코드는 그 자체로 시스템의 기능과 사용법을 보여주는 '살아있는 문서' 역할을 합니다. 잘 작성된 테스트 코드는 항상 현재 시스템의 동작을 정확하게 반영합니다.
- **명확하고 서술적인 이름**: 테스트의 의도가 명확히 드러나도록 `[단위]는 [상황]에서 [기대 행동]을 해야 한다`와 같은 서술적인 이름을 사용합니다.
- **독립적이고 집중된 테스트**: 각 테스트는 독립적으로 실행 가능해야 하며, 하나의 테스트는 하나의 핵심 기능만 검증하도록 집중합니다.
- **구조의 일관성**: `준비(Arrange) - 실행(Act) - 단언(Assert)` 패턴을 일관되게 사용하여 가독성을 높입니다.


