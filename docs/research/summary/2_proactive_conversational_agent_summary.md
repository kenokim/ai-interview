# LangGraph를 활용한 프로액티브 대화형 에이전트 아키텍처 설계 요약

이 문서는 사용자의 입력에 반응하는 전통적인 챗봇을 넘어, 특정 조건이나 이벤트에 따라 AI가 먼저 대화를 시작하는 '프로액티브(Proactive)' 대화형 에이전트를 LangGraph로 구축하는 방법론과 아키텍처를 심도 있게 다룹니다.

## 핵심 개념: 트리거와 로직의 분리

- **패러다임 전환**: 챗봇의 실행 '촉매'를 사용자 입력(반응형)에서 외부 시스템 이벤트(프로액티브)로 전환하는 것이 핵심입니다. LangGraph로 컴파일된 에이전트는 본질적으로 호출 가능한 '비활성 상태 기계'이며, 무엇이 그것을 호출하는지에 따라 성격이 결정됩니다.
- **관심사 분리**: 이 설계는 '트리거'와 에이전트의 핵심 '로직'을 분리하여, 잘 설계된 하나의 에이전트 로직을 다양한 시나리오(웹훅, 스케줄러, 사용자 입력 등)에서 높은 재사용성으로 활용할 수 있게 합니다.
- **상태 설계**: 프로액티브 실행의 맥락(`trigger_context`)과 일반 대화 기록(`messages`)을 모두 처리할 수 있는 유연한 상태 스키마(`AgentState`)를 설계하고, 초기 상태의 내용에 따라 그래프의 진입점(Entry Point)을 다르게 설정하는 것이 중요합니다.

## 2가지 핵심 아키텍처 패턴

1.  **이벤트 기반 API 패턴 (FastAPI 활용)**
    - **사용 사례**: 사용자 가입, 상품 구매 등 예측 불가능한 이벤트에 실시간으로 반응할 때 이상적입니다.
    - **구조**: 외부 시스템이 특정 이벤트 발생 시 FastAPI로 구현된 API 엔드포인트를 호출합니다. API 서버는 요청 데이터를 바탕으로 `AgentState`를 구성하고 LangGraph 에이전트를 비동기적으로 호출(`ainvoke`)하여 대화를 시작합니다.

2.  **시간 기반 스케줄러 패턴 (APScheduler 활용)**
    - **사용 사례**: 일일 뉴스 브리핑, 주간 보고서 등 정해진 시간에 반복적으로 작업을 수행할 때 적합합니다.
    - **구조**: `APScheduler`와 같은 스케줄링 라이브러리를 사용하여 백그라운드에서 주기적으로 특정 잡(job) 함수를 실행합니다. 이 함수는 DB 조회 등을 통해 대상 목록을 가져와 각 대상에 대한 `AgentState`를 구성하고 `invoke`를 호출하여 프로액티브 대화를 시작합니다.

## 그래프 내부 로직 설계

- **Initiator 노드**: 프로액티브 흐름의 첫 노드로, `trigger_context`를 입력받아 개인화된 첫 AI 메시지를 생성합니다. 간단한 경우 템플릿 기반으로, 복잡한 경우 LLM을 호출하여 동적으로 생성할 수 있습니다.
- **대화로의 전환 (Interrupt)**: AI의 일방적인 독백으로 끝나지 않으려면, 첫 메시지 전송 후 사용자의 응답을 기다려야 합니다. `langgraph.types.interrupt`를 반환하는 노드를 추가하여 그래프 실행을 의도적으로 일시 중지시키고 제어권을 외부 애플리케이션으로 넘깁니다. 사용자가 응답하면 동일한 `thread_id`로 그래프를 다시 호출하여 대화를 재개합니다.
- **타임아웃 처리**: 사용자가 응답하지 않아 영원히 중단된 '고스팅(ghosting)' 스레드는 별도의 스케줄러 잡을 통해 주기적으로 정리(timeout)하는 아키텍처적 해결책이 필요합니다.

## 프로덕션 운영을 위한 고려사항

- **상태 지속성 및 멱등성**: 프로덕션 환경에서는 반드시 Redis나 DB 기반의 영구적인 `Checkpointer`를 사용해야 합니다. 또한, 네트워크 문제로 인한 중복 이벤트 처리를 방지하기 위해, 고유한 `trigger_event_id`를 상태에 기록하고 조건부 라우터를 통해 이미 처리된 이벤트인지 확인하는 **멱등성** 확보가 필수적입니다.
- **개인화, 보안, 동의**: 프로액티브 메시지의 성공은 **개인화**에 달려있습니다. 또한, GDPR 등 규제 준수를 위해 명시적인 사용자 동의(Opt-in), 쉬운 거부(Opt-out), 투명성 확보 및 데이터 보안이 매우 중요합니다.
- **오류 처리**: API 엔드포인트의 표준 HTTP 오류 처리, 그래프 노드 내의 `try...except` 블록을 통한 예외 처리 및 '오류 처리' 노드로의 정상적인 흐름 유도가 필요합니다.

## 결론

프로액티브 에이전트의 핵심은 LangGraph의 특정 기능이 아니라, **트리거와 로직을 분리하는 아키텍처 설계**에 있습니다. 이 접근법은 사용자의 필요를 예측하고 먼저 다가가는 차세대 '앰비언트 에이전트'로 나아가는 중요한 단계입니다. 